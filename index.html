<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Intraday Forecast Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --primary-color: #63AB8F;
      --secondary-color: #4A8C7D;
      --border-color: #DEE2E6;
      --light-bg: #F8F9FA;
      --card-bg: #FFFFFF;
      --text-color: #2C3E50;
      --text-light: #6C757D;
      --pill: #e9f6f0;
    }

    body {
      font-family: 'Aptos', 'Segoe UI', system-ui, -apple-system, Arial, sans-serif;
      margin: 20px;
      padding: 20px;
      max-width: 1400px;
      background: var(--light-bg);
      color: var(--text-color);
    }

    #logo-container {
      text-align: center;
      margin-bottom: 20px;
    }

    #logo {
      width: 300px;
    }

    h1 {
      margin: 0 0 16px;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 24px;
      margin-top: 16px;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 14px;
    }

    input, select, button, textarea {
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: #fff;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }

    button {
      background: var(--primary-color);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: background .2s;
      border: none;
    }

    button:hover {
      background: var(--secondary-color);
    }

    button:disabled {
      background: var(--text-light);
      cursor: not-allowed;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      align-items: end;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-height: 82px;
    }

    .full-width-btn {
      width: 100%;
      padding: 14px 18px;
      font-size: 16px;
      margin-top: 0;
    }

    .muted {
      color: var(--text-light);
      font-size: 12px;
      margin-top: 4px;
      line-height: 1.3;
    }

    .section-title {
      margin: 0 0 10px;
      color: var(--secondary-color);
    }

    #messageContainer {
      display: none;
      margin-top: 12px;
    }

    .error-message {
      color: #b4231a;
      background: #fee2e2;
      border: 1px solid #fecaca;
      padding: 10px;
      border-radius: 6px;
    }

    .success-message {
      color: #14532d;
      background: #dcfce7;
      border: 1px solid #bbf7d0;
      padding: 10px;
      border-radius: 6px;
    }

    .info-message {
      color: #6b4e16;
      background: #fff7ed;
      border: 1px solid #ffedd5;
      padding: 10px;
      border-radius: 6px;
    }

    /* Table Styling */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      overflow: hidden;
    }

    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
      vertical-align: middle;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 600;
    }

    tr:hover {
      background-color: rgba(99, 171, 143, 0.05);
    }

    .consolidated-table th.group-header {
      background-color: var(--secondary-color);
      text-align: center;
    }

    .consolidated-table th.sub-header {
      background-color: rgba(99, 171, 143, 0.8);
    }

    .weekly-totals-row {
      background-color: rgba(99, 171, 143, 0.1);
      font-weight: 600;
    }

    .weekly-totals-row td {
      border-bottom: 2px solid var(--primary-color);
    }

    /* Tab Styling */
    .tab {
      display: inline-block;
      padding: 12px 20px;
      margin-right: 10px;
      background: #eee;
      cursor: pointer;
      border-radius: 6px;
      font-weight: 500;
    }

    .tab.active {
      background: var(--primary-color);
      color: white;
      font-weight: 600;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .no-data {
      color: var(--text-light);
      font-style: italic;
      text-align: center;
      padding: 20px;
    }

    .loading {
      color: var(--text-light);
      font-style: italic;
      text-align: center;
      padding: 20px;
    }

    .table-container {
      overflow-x: auto;
      margin-top: 20px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 1px;
    }

    .metrics-section {
      margin-bottom: 30px;
    }

    .metrics-section h3 {
      color: var(--secondary-color);
      margin-bottom: 15px;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 5px;
    }

    /* Chart Styles */
    .chart-container {
      margin: 20px 0;
      padding: 20px;
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      height: 400px;
    }

    .chart-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .chart-controls select {
      width: auto;
      min-width: 200px;
    }

    /* Clickable rows */
    .clickable-row {
      cursor: pointer;
    }

    .clickable-row:hover {
      background-color: rgba(99, 171, 143, 0.1) !important;
    }

    /* Progress bar styles */
    .progress-container {
      width: 100%;
      margin: 20px 0;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #e9ecef;
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-details {
      font-size: 12px;
      color: var(--text-light);
      margin-top: 5px;
      text-align: center;
    }

    /* Interval controls */
    .interval-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      padding: 15px;
      background: var(--light-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      flex-wrap: wrap;
    }

    .interval-control-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
    }

    .interval-control-group label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      body {
        margin: 10px;
        padding: 10px;
      }
      
      .card {
        padding: 16px;
      }
      
      .controls {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .tab {
        padding: 10px 15px;
        font-size: 14px;
      }
      
      .chart-controls {
        flex-direction: column;
      }
      
      .chart-controls select {
        width: 100%;
      }
      
      .interval-controls {
        flex-direction: column;
      }
      
      .interval-control-group {
        min-width: 100%;
      }
    }

    .auth-container {
      text-align: center;
      padding: 40px;
    }

    .auth-button {
      display: inline-block;
      background: var(--primary-color);
      color: white;
      padding: 15px 30px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      font-size: 16px;
      margin: 20px 0;
    }

    .auth-button:hover {
      background: var(--secondary-color);
    }

    .chart-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .chart-tab {
      padding: 8px 16px;
      background: #eee;
      border-radius: 4px;
      cursor: pointer;
    }

    .chart-tab.active {
      background: var(--primary-color);
      color: white;
    }

    .time-format-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--primary-color);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .toggle-label {
      font-size: 14px;
      font-weight: 600;
    }

    .export-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .export-btn {
      background: var(--secondary-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .export-btn:hover {
      background: var(--primary-color);
    }

    .rate-limit-warning {
      background: #fff7ed;
      border: 1px solid #ffedd5;
      color: #6b4e16;
      padding: 10px 15px;
      border-radius: 6px;
      margin-top: 15px;
      font-size: 13px;
      display: none;
    }

    /* Checkbox dropdown styles (from your queue management tool) */
    .checkbox-dropdown {
      position: relative;
      min-width: 240px;
      width: 100%;
    }
    
    .cd-trigger {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: #fff;
      padding: 10px;
      cursor: pointer;
      width: 100%;
      box-sizing: border-box;
    }
    
    .cd-trigger .label {
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }
    
    .cd-trigger .count {
      background: var(--pill);
      border: 1px solid var(--border-color);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
      color: #2c3e50;
      flex-shrink: 0;
      margin-left: 8px;
    }
    
    .cd-panel {
      position: absolute;
      z-index: 1000;
      margin-top: 6px;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
      width: 100%;
      max-height: 340px;
      overflow: hidden;
      display: none;
      box-sizing: border-box;
    }
    
    .cd-panel.open {
      display: block;
    }
    
    .cd-header {
      padding: 10px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .cd-search {
      flex: 1;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .cd-actions {
      display: flex;
      gap: 8px;
    }
    
    .cd-actions button {
      background: #eef6f2;
      color: #2c3e50;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 10px;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .cd-selectall {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .cd-list {
      max-height: 260px;
      overflow: auto;
    }
    
    .cd-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-bottom: 1px solid #f1f3f5;
    }
    
    .cd-item label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      width: 100%;
    }
    
    .cd-footer {
      padding: 8px 12px;
      background: #fafafa;
      border-top: 1px solid var(--border-color);
      font-size: 12px;
      color: var(--text-light);
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/Management-Unit-Search/main/Consultinglogo%20(2).png" alt="Company Logo">
  </div>

  <h1>Intraday Forecast Dashboard</h1>

  <div id="authCard" class="card">
    <div id="auth-message" class="info-message">Authenticating with PureCloud...</div>
  </div>

  <!-- Debug (shows only when ?debug=1 is in the URL) -->
  <div id="authDebug" class="card" style="display:none">
    <h2 class="section-title">Auth debug</h2>
    <p class="muted">This block appears when you add <code>?debug=1</code> to the page URL.</p>
    <pre id="authDump" class="debug"></pre>
    <button id="signinBtn">Sign in with Genesys</button>
  </div>

  <div id="appContent" style="display:none;">
    <div id="messageContainer"></div>

    <div class="card">
      <h2 class="section-title">Configuration</h2>
      <div class="controls">
        <div class="control-group">
          <label for="businessUnitSelect">Business Unit:</label>
          <select id="businessUnitSelect" disabled>
            <option value="">-- Loading Business Units --</option>
          </select>
        </div>
        <div class="control-group">
          <label for="planningGroupDropdown">Planning Group:</label>
          <div id="planningGroupDropdown" class="checkbox-dropdown"></div>
          <div class="muted"></div>
        </div>
        <div class="control-group">
          <label for="dateFrom">Date From:</label>
          <input type="date" id="dateFrom" class="calendar-input">
        </div>
        <div class="control-group">
          <label for="dateTo">Date To:</label>
          <input type="date" id="dateTo" class="calendar-input">
        </div>
        <div class="control-group">
          <label for="mediaType">Media Type:</label>
          <select id="mediaType">
            <option value="">-- All Media Types --</option>
            <option value="Voice">Voice</option>
            <option value="Message">Message</option>
          </select>
        </div>
        <div class="control-group">
          <label>&nbsp;</label>
          <button id="loadDataBtn" class="full-width-btn" disabled>
            Load Forecast Data
          </button>
          <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-details" id="progressDetails"></div>
          </div>
          <div class="rate-limit-warning" id="rateLimitWarning">
            <strong>‚ö†Ô∏è Large Date Range Detected:</strong> Loading more than 30 days may take longer. Please Wait. . .
          </div>
        </div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="card">
      <div style="margin-bottom: 20px;">
        <div id="tabs">
          <div id="dailyTabButton" class="tab active">Forecast Data</div>
          <div id="intervalTabButton" class="tab">Interval Data</div>
          <div id="chartsTabButton" class="tab">Charts & Analytics</div>
        </div>
      </div>
      
      <div id="dailyTab" class="tab-content active">
        <div class="chart-controls">
          <div>
            <label for="viewType">View Type:</label>
            <select id="viewType">
              <option value="daily">Daily View</option>
              <option value="weekly">Weekly View</option>
              <option value="monthly">Monthly View</option>
            </select>
          </div>
          <div class="time-format-toggle">
            <span class="toggle-label">Time Format:</span>
            <label class="toggle-switch">
              <input type="checkbox" id="timeFormatToggle">
              <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label" id="timeFormatLabel">HH:MM:SS</span>
          </div>
        </div>
        <div class="export-buttons">
          <button class="export-btn" id="exportForecastBtn">Export Forecast Data to CSV</button>
        </div>
        <h2 class="section-title">Forecast Data</h2>
        <div id="weeklySummary" class="loading">Select date range and click "Load Forecast Data" to view forecast and predictions</div>
        <div class="metrics-section" id="consolidatedSection" style="display: none;">
          <h3>üìä Forecast & Performance Predictions</h3>
          <div id="consolidatedTableContainer"></div>
        </div>
      </div>
      
      <div id="intervalTab" class="tab-content">
        <div class="interval-controls">
          <div class="interval-control-group">
            <label for="intervalLength">Interval Length:</label>
            <select id="intervalLength">
              <option value="15">15 minutes</option>
              <option value="30">30 minutes</option>
              <option value="45">45 minutes</option>
              <option value="60">60 minutes</option>
            </select>
          </div>
          <div class="interval-control-group">
            <label for="openTime">Open Time:</label>
            <input type="time" id="openTime" value="08:00">
          </div>
          <div class="interval-control-group">
            <label for="closeTime">Close Time:</label>
            <input type="time" id="closeTime" value="18:00">
          </div>
          <div class="interval-control-group">
            <label for="applyIntervalFilter">Apply Filter:</label>
            <button id="applyIntervalFilter">Apply Time Filter</button>
          </div>
        </div>
        <div class="chart-controls">
          <div class="time-format-toggle">
            <span class="toggle-label">Time Format:</span>
            <label class="toggle-switch">
              <input type="checkbox" id="intervalTimeFormatToggle">
              <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label" id="intervalTimeFormatLabel">HH:MM:SS</span>
          </div>
        </div>
        <div class="export-buttons">
          <button class="export-btn" id="exportIntervalBtn">Export Interval Data to CSV</button>
        </div>
        <h2 class="section-title">Interval Data for <span id="selectedDayTitle"></span></h2>
        <div id="intervalTableContainer" class="loading">Click on a day in the Forecast Data tab to view interval data</div>
      </div>

      <div id="chartsTab" class="tab-content">
        <h2 class="section-title">Charts & Analytics</h2>
        <div class="chart-controls">
          <div>
            <label for="chartViewType">View Type:</label>
            <select id="chartViewType">
              <option value="daily">Daily View</option>
              <option value="weekly">Weekly View</option>
              <option value="monthly">Monthly View</option>
            </select>
          </div>
        </div>
        
        <div class="chart-tabs">
          <div class="chart-tab active" data-chart="volume">Volume & AHT</div>
          <div class="chart-tab" data-chart="serviceLevel">Service Level Predictions</div>
          <div class="chart-tab" data-chart="occupancy">Occupancy Predictions</div>
        </div>
        
        <div class="chart-container">
          <canvas id="metricsChart"></canvas>
        </div>
        <div id="chartsDataContainer" class="loading">Load forecast data to view charts</div>
      </div>
    </div>
  </div>

  <script>
    // ===== Configuration =====
    const CONFIG = {
      clientId: 'fe305808-b368-4547-8af9-325d28d552bb',
      region: 'mypurecloud.ie',
      timeFormat: 'seconds',
      precision: 1,
      maxDaysPerRequest: 7, // Maximum days to fetch in a single batch
      delayBetweenRequests: 500, // Delay between individual day requests
      delayBetweenBatches: 2000, // Longer delay between batches
      maxConcurrentRequests: 3, // Maximum concurrent requests
      progressUpdateInterval: 100 // Update progress every 100ms
    };

    const DEBUG = new URLSearchParams(window.location.search).has('debug');
    const redirectUri = new URL('.', window.location.href).href;
    const oauthUrl = `https://login.${CONFIG.region}/oauth/authorize?client_id=${encodeURIComponent(CONFIG.clientId)}&response_type=token&redirect_uri=${encodeURIComponent(redirectUri)}&state=intraday`;

    // ===== Application State =====
    const state = {
      accessToken: null,
      dateRangeData: [],
      planningGroupsMap: {},
      dateFrom: null,
      dateTo: null,
      viewType: 'daily',
      charts: {},
      selectedDayForIntervals: null,
      selectedDayData: null,
      isDataLoaded: false,
      currentChartType: 'volume',
      timeFormat: 'hhmmss', // 'hhmmss' or 'seconds'
      currentIntervalData: null,
      isFetchingData: false,
      fetchCancelled: false,
      planningGroupDropdown: null,
      selectedPlanningGroups: [],
      intervalFilter: {
        openTime: '08:00',
        closeTime: '18:00',
        intervalLength: 15
      }
    };

    // ===== Checkbox Dropdown Component =====
    function createCheckboxDropdown(containerId, { placeholder, searchPlaceholder }) {
      const root = document.getElementById(containerId);
      root.innerHTML = '';

      const trigger = document.createElement('div');
      trigger.className = 'cd-trigger';
      trigger.innerHTML = `<span class="label">${placeholder}</span><span class="count">0 selected</span>`;
      root.appendChild(trigger);

      const panel = document.createElement('div');
      panel.className = 'cd-panel';
      panel.innerHTML = `
        <div class="cd-header">
          <input type="text" class="cd-search" placeholder="${searchPlaceholder}" />
          <div class="cd-actions">
            <button type="button" data-cd="clear">Clear</button>
          </div>
        </div>
        <div class="cd-selectall">
          <label><input type="checkbox" data-cd="selectall"/> Select all</label>
        </div>
        <div class="cd-list"></div>
        <div class="cd-footer">
          <span data-cd="summary">0 selected</span>
          <span>Click outside to close</span>
        </div>
      `;
      root.appendChild(panel);

      const list = panel.querySelector('.cd-list');
      const search = panel.querySelector('.cd-search');
      const clearBtn = panel.querySelector('[data-cd="clear"]');
      const selectAll = panel.querySelector('[data-cd="selectall"]');
      const summary = panel.querySelector('[data-cd="summary"]');

      let options = []; // [{value, label}]
      let selected = new Set();

      function render(filter='') {
        const ft = filter.trim().toLowerCase();
        list.innerHTML = '';
        const filtered = !ft ? options : options.filter(o => (o.label||'').toLowerCase().includes(ft));
        if (!filtered.length){ 
          list.innerHTML = `<div class="cd-item" style="color:#6C757D">No matches</div>`; 
          return; 
        }
        filtered.forEach(o => {
          const id = `${containerId}__${o.value}`;
          const row = document.createElement('div');
          row.className = 'cd-item';
          row.innerHTML = `
            <label for="${id}">
              <input type="checkbox" id="${id}" value="${o.value}" ${selected.has(o.value)?'checked':''}/>
              <span>${o.label || o.value}</span>
            </label>
          `;
          const cb = row.querySelector('input');
          cb.addEventListener('change', () => {
            if (cb.checked) selected.add(o.value); 
            else selected.delete(o.value);
            updateSummary(); 
            updateSelectAllState();
            updateLoadButtonState();
          });
          list.appendChild(row);
        });
      }

      function updateSummary() {
        trigger.querySelector('.count').textContent = `${selected.size} selected`;
        summary.textContent = `${selected.size} selected`;
      }

      function updateSelectAllState() {
        const total = options.length, count = selected.size;
        selectAll.indeterminate = count > 0 && count < total;
        selectAll.checked = total > 0 && count === total;
      }

      trigger.addEventListener('click', () => { 
        panel.classList.toggle('open'); 
        search.focus(); 
      });
      
      document.addEventListener('click', (e) => { 
        if (!root.contains(e.target)) panel.classList.remove('open'); 
      });
      
      search.addEventListener('input', () => render(search.value));
      
      clearBtn.addEventListener('click', () => { 
        selected.clear(); 
        render(search.value); 
        updateSummary(); 
        updateSelectAllState();
        updateLoadButtonState();
      });
      
      selectAll.addEventListener('change', () => {
        if (selectAll.checked) options.forEach(o => selected.add(o.value)); 
        else selected.clear();
        render(search.value); 
        updateSummary();
        updateLoadButtonState();
      });

      function setOptions(newOptions) {
        options = newOptions || [];
        selected.forEach(v => { 
          if (!options.some(o => o.value === v)) selected.delete(v); 
        });
        render(search.value); 
        updateSummary(); 
        updateSelectAllState();
      }

      function getSelectedValues() { 
        return Array.from(selected); 
      }

      function setSelectedValues(values) {
        selected = new Set(values);
        render(search.value);
        updateSummary();
        updateSelectAllState();
      }

      render('');
      return { setOptions, getSelectedValues, setSelectedValues };
    }

    // ===== Utility Functions =====
    function getMonday(date) {
      const d = new Date(date);
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      return new Date(d.setDate(diff));
    }

    function formatTime(seconds) {
      if (seconds === null || seconds === undefined) return '-';
      seconds = Math.round(seconds);
      
      if (state.timeFormat === 'seconds') {
        return seconds.toString();
      } else {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return h > 0 ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}` : `${m}:${s.toString().padStart(2, '0')}`;
      }
    }

    function formatNumber(num) {
      if (num === null || num === undefined) return '-';
      return Number.isFinite(num) ? Math.round(num).toString() : '-';
    }

    function formatPercentage(num) {
      if (num === null || num === undefined) return '-';
      const value = num * 100;
      const cappedValue = Math.min(value, 100);
      return Number.isFinite(cappedValue) ? cappedValue.toFixed(CONFIG.precision) + '%' : '-';
    }

    function getUKFormattedDate(date) {
      const d = date.getDate();
      const m = date.getMonth() + 1;
      const y = date.getFullYear();
      return `${d.toString().padStart(2, '0')}/${m.toString().padStart(2, '0')}/${y}`;
    }

    function getDOWFromUK(ukDate) {
      const [dd, mm, yyyy] = ukDate.split('/').map(Number);
      const dt = new Date(yyyy, mm - 1, dd);
      return dt.toLocaleDateString('en-GB', { weekday: 'short' });
    }

    function isoDate(date) {
      const dt = new Date(date);
      dt.setHours(12, 0, 0, 0);
      const offsetDate = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000);
      return offsetDate.toISOString().split('T')[0];
    }

    function getDateRange(startDate, endDate) {
      const dates = [];
      const current = new Date(startDate);
      const end = new Date(endDate);
      
      while (current <= end) {
        dates.push({
          raw: isoDate(current),
          uk: getUKFormattedDate(current),
          date: new Date(current)
        });
        current.setDate(current.getDate() + 1);
      }
      return dates;
    }

    function computePredictionFallback(grouping) {
      const per = grouping?.forecastDataPerInterval || [];
      let slSum = 0, slCnt = 0, asaSum = 0, asaCnt = 0, occSum = 0, occCnt = 0;
      
      per.forEach(x => {
        if (!x) return;
        if (x.performancePrediction && x.performancePrediction.serviceLevelPercent !== undefined) { 
          slSum += x.performancePrediction.serviceLevelPercent; 
          slCnt++; 
        }
        if (x.performancePrediction && x.performancePrediction.averageSpeedOfAnswerSeconds !== undefined) { 
          asaSum += x.performancePrediction.averageSpeedOfAnswerSeconds; 
          asaCnt++; 
        }
        if (x.performancePrediction && x.performancePrediction.occupancyPercent !== undefined) { 
          occSum += x.performancePrediction.occupancyPercent; 
          occCnt++; 
        }
      });
      
      return {
        serviceLevelPercent: slCnt ? slSum / slCnt : null,
        averageSpeedOfAnswerSeconds: asaCnt ? asaSum / asaCnt : null,
        occupancyPercent: occCnt ? occSum / occCnt : null
      };
    }

    function getPerformancePredictionData(groupData) {
      if (groupData.performancePredictionDataSummary) {
        const pred = groupData.performancePredictionDataSummary;
        return {
          serviceLevelPercent: pred.serviceLevelPercent,
          averageSpeedOfAnswerSeconds: pred.averageSpeedOfAnswerSeconds,
          occupancyPercent: pred.occupancyPercent
        };
      }
      
      const fallback = computePredictionFallback(groupData);
      return fallback;
    }

    function showMessage(msg, type = 'error', details = '') {
      const box = document.getElementById('messageContainer');
      let html = `<div class="${type}-message">${msg}</div>`;
      
      if (details && DEBUG) {
        html += `<div class="info-message" style="margin-top:8px;">
          <pre style="font-size:11px;overflow:auto;">${JSON.stringify(details, null, 2)}</pre>
        </div>`;
      }
      
      box.innerHTML = html;
      box.style.display = 'block';
      
      if (type === 'success') {
        setTimeout(() => box.style.display = 'none', 5000);
      }
    }

    function updateTimeFormatLabels() {
      const label = document.getElementById('timeFormatLabel');
      const intervalLabel = document.getElementById('intervalTimeFormatLabel');
      
      if (state.timeFormat === 'seconds') {
        label.textContent = 'Seconds';
        intervalLabel.textContent = 'Seconds';
      } else {
        label.textContent = 'HH:MM:SS';
        intervalLabel.textContent = 'HH:MM:SS';
      }
    }

    // ===== Progress Bar Functions =====
    function showProgressBar() {
      const container = document.getElementById('progressContainer');
      container.style.display = 'block';
      
      const warning = document.getElementById('rateLimitWarning');
      const dateFrom = new Date(document.getElementById('dateFrom').value);
      const dateTo = new Date(document.getElementById('dateTo').value);
      const dayCount = Math.ceil((dateTo - dateFrom) / (1000 * 60 * 60 * 24)) + 1;
      
      if (dayCount > 30) {
        warning.style.display = 'block';
      } else {
        warning.style.display = 'none';
      }
    }

    function hideProgressBar() {
      const container = document.getElementById('progressContainer');
      container.style.display = 'none';
    }

    function updateProgress(current, total, status = '') {
      const percentage = Math.round((current / total) * 100);
      document.getElementById('progressFill').style.width = `${percentage}%`;
      document.getElementById('progressDetails').textContent = status || `Processing ${current} of ${total} days`;
    }

    // ===== CSV Export Functions =====
    function exportToCSV(filename, csvData) {
      const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function exportForecastData() {
      if (!state.isDataLoaded) {
        showMessage('No data to export', 'error');
        return;
      }

      const planningGroups = groupsPresent();
      let csvContent = 'Planning Group,Period,Offered,Avg Handle Time,Service Level,Avg Speed Answer,Occupancy,Staffed\n';
      
      planningGroups.forEach(group => {
        const groupData = state.dateRangeData.map(day => ({
          ...day,
          groupData: day.groupData?.filter(g => !g.planningGroupId || g.planningGroupId === group.id) || []
        }));

        const viewType = document.getElementById('viewType').value;
        const aggregatedData = aggregateDataByPeriod(groupData, viewType);
        
        aggregatedData.forEach(period => {
          const row = [
            group.name,
            period.label,
            period.offered ? Math.round(period.offered).toString() : '0',
            period.ahtCount > 0 ? Math.round(period.aht / period.ahtCount).toString() : '0',
            period.slCount > 0 ? (period.sl / period.slCount * 100).toFixed(CONFIG.precision) + '%' : '-',
            period.asaCount > 0 ? Math.round(period.asa / period.asaCount).toString() : '0',
            period.occupancyCount > 0 ? (period.occupancy / period.occupancyCount * 100).toFixed(CONFIG.precision) + '%' : '-',
            period.staffed ? Math.round(period.staffed).toString() : '0'
          ];
          
          csvContent += row.join(',') + '\n';
        });
      });

      const filename = `forecast_data_${state.dateFrom}_to_${state.dateTo}.csv`;
      exportToCSV(filename, csvContent);
    }

    function exportIntervalData() {
      if (!state.currentIntervalData) {
        showMessage('No interval data to export', 'error');
        return;
      }

      let csvContent = 'Planning Group,Time,Offered,Avg Handle Time,Service Level,Avg Speed Answer,Occupancy,Staffed\n';
      
      state.currentIntervalData.forEach(groupData => {
        groupData.intervals.forEach(interval => {
          const row = [
            groupData.groupName,
            interval.time,
            interval.offered.toString(),
            interval.aht.toString(),
            interval.sl || '-',
            interval.asa.toString(),
            interval.occupancy || '-',
            interval.staffed.toString()
          ];
          
          csvContent += row.join(',') + '\n';
        });
      });

      const filename = `interval_data_${state.selectedDayForIntervals}.csv`;
      exportToCSV(filename, csvContent);
    }

    // ===== Data Aggregation Functions =====
    function aggregateDataByPeriod(data, periodType) {
      console.log(`Aggregating ${data.length} days by ${periodType} view`);
      
      // For daily view, return individual days without aggregation
      if (periodType === 'daily') {
        return data.map(day => {
          if (!day.date || !day.groupData || day.groupData.length === 0) {
            return null;
          }
          
          let offered = 0, aht = 0, ahtCount = 0, sl = 0, slCount = 0, 
              asa = 0, asaCount = 0, occupancy = 0, occupancyCount = 0, staffed = 0;
          
          day.groupData.forEach(group => {
            offered += group.forecast.offered || 0;
            aht += group.forecast.averageHandleTimeSeconds || 0;
            ahtCount += (group.forecast.averageHandleTimeSeconds && group.forecast.averageHandleTimeSeconds > 0) ? 1 : 0;
            
            if (group.prediction.serviceLevelPercent !== null && group.prediction.serviceLevelPercent !== undefined) {
              sl += group.prediction.serviceLevelPercent;
              slCount++;
            }
            
            if (group.prediction.averageSpeedOfAnswerSeconds !== null && group.prediction.averageSpeedOfAnswerSeconds !== undefined) {
              asa += group.prediction.averageSpeedOfAnswerSeconds;
              asaCount++;
            }
            
            if (group.prediction.occupancyPercent !== null && group.prediction.occupancyPercent !== undefined) {
              occupancy += group.prediction.occupancyPercent;
              occupancyCount++;
            }
            
            staffed += group.forecast.staffed || 0;
          });
          
          return {
            offered: offered,
            aht: aht,
            ahtCount: ahtCount,
            sl: sl,
            slCount: slCount,
            asa: asa,
            asaCount: asaCount,
            occupancy: occupancy,
            occupancyCount: occupancyCount,
            staffed: staffed,
            label: `${getDOWFromUK(day.uk)} ${day.uk}`,
            startDate: new Date(day.date),
            endDate: new Date(day.date),
            daysInPeriod: 1,
            rawDate: day.uk
          };
        }).filter(day => day !== null);
      }
      
      // For weekly and monthly views
      const aggregated = {};
      
      data.forEach(day => {
        if (!day.date || !day.groupData || day.groupData.length === 0) {
          return;
        }
        
        let periodKey;
        let periodLabel;
        const date = day.date;
        
        switch (periodType) {
          case 'weekly':
            const weekStart = getMonday(date);
            periodKey = `week-${weekStart.toISOString().split('T')[0]}`;
            periodLabel = `WC ${getUKFormattedDate(weekStart)}`;
            break;
          case 'monthly':
            periodKey = `month-${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
            periodLabel = date.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
            break;
          default:
            periodKey = `day-${day.raw}`;
            periodLabel = `${getDOWFromUK(day.uk)} ${day.uk}`;
        }
        
        if (!aggregated[periodKey]) {
          aggregated[periodKey] = {
            offered: 0,
            aht: 0,
            ahtCount: 0,
            sl: 0,
            slCount: 0,
            asa: 0,
            asaCount: 0,
            occupancy: 0,
            occupancyCount: 0,
            staffed: 0,
            label: periodLabel,
            startDate: new Date(date),
            endDate: new Date(date),
            daysInPeriod: 0
          };
        }
        
        const period = aggregated[periodKey];
        
        if (date < period.startDate) period.startDate = new Date(date);
        if (date > period.endDate) period.endDate = new Date(date);
        period.daysInPeriod++;
        
        day.groupData.forEach(group => {
          period.offered += group.forecast.offered || 0;
          period.aht += group.forecast.averageHandleTimeSeconds || 0;
          period.ahtCount += (group.forecast.averageHandleTimeSeconds && group.forecast.averageHandleTimeSeconds > 0) ? 1 : 0;
          
          if (group.prediction.serviceLevelPercent !== null && group.prediction.serviceLevelPercent !== undefined) {
            period.sl += group.prediction.serviceLevelPercent;
            period.slCount++;
          }
          
          if (group.prediction.averageSpeedOfAnswerSeconds !== null && group.prediction.averageSpeedOfAnswerSeconds !== undefined) {
            period.asa += group.prediction.averageSpeedOfAnswerSeconds;
            period.asaCount++;
          }
          
          if (group.prediction.occupancyPercent !== null && group.prediction.occupancyPercent !== undefined) {
            period.occupancy += group.prediction.occupancyPercent;
            period.occupancyCount++;
          }
          
          period.staffed += group.forecast.staffed || 0;
        });
      });
      
      return Object.values(aggregated);
    }

    // ===== API Functions =====
    async function fetchPaginatedData(url, options = {}) {
      let allEntities = [];
      let nextUrl = url;
      
      while (nextUrl) {
        const response = await fetch(nextUrl, {
          headers: {
            'Authorization': 'Bearer ' + state.accessToken,
            ...options.headers
          },
          ...options
        });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        if (data.entities) {
          allEntities = allEntities.concat(data.entities);
        } else if (data.results) {
          allEntities = allEntities.concat(data.results);
        } else {
          return data;
        }
        
        nextUrl = data.nextUri ? `https://api.${CONFIG.region}${data.nextUri}` : null;
      }
      
      return allEntities;
    }

    async function pollIntradayResult(businessUnitId, operationId, { maxAttempts = 12, delayMs = 750 } = {}) {
      for (let i = 1; i <= maxAttempts; i++) {
        const response = await fetch(`https://api.${CONFIG.region}/api/v2/workforcemanagement/businessunits/${businessUnitId}/intraday/${operationId}`, {
          headers: { 'Authorization': 'Bearer ' + state.accessToken }
        });
        
        if (!response.ok) throw new Error(`Polling failed: ${response.status}`);
        const data = await response.json();
        
        if (data.status === 'Complete' && data.result) return data;
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
      
      throw new Error('Intraday operation timed out');
    }

    // ===== Data Fetching =====
    async function fetchBusinessUnits() {
      try {
        const businessUnits = await fetchPaginatedData(
          `https://api.${CONFIG.region}/api/v2/workforcemanagement/businessunits?pageSize=100`
        );
        
        const select = document.getElementById('businessUnitSelect');
        select.innerHTML = '<option value="">-- Select Business Unit --</option>';
        
        businessUnits.forEach(bu => {
          const option = document.createElement('option');
          option.value = bu.id;
          option.textContent = bu.name;
          select.appendChild(option);
        });
        
        select.disabled = false;
      } catch (error) {
        showMessage('Error loading business units: ' + error.message, 'error');
      }
    }

    async function fetchPlanningGroups(businessUnitId) {
      try {
        const planningGroups = await fetchPaginatedData(
          `https://api.${CONFIG.region}/api/v2/workforcemanagement/businessunits/${businessUnitId}/planninggroups?pageSize=100`
        );
        
        // Update planning groups map
        state.planningGroupsMap = {};
        planningGroups.forEach(pg => {
          state.planningGroupsMap[pg.id] = pg.name;
        });

        // Update dropdown options
        const options = planningGroups.map(pg => ({
          value: pg.id,
          label: pg.name
        })).sort((a, b) => a.label.localeCompare(b.label));

        state.planningGroupDropdown.setOptions(options);
        
        updateLoadButtonState();
      } catch (error) {
        showMessage('Error loading planning groups: ' + error.message, 'error');
      }
    }

    async function fetchIntradayData(date, planningGroupIds = []) {
      const businessUnitId = document.getElementById('businessUnitSelect').value;
      
      if (!businessUnitId) {
        return { date, data: null, error: 'No business unit selected' };
      }
      
      try {
        const requestBody = {
          businessUnitDate: date,
          categories: ["ForecastData", "ScheduleData", "PerformancePredictionData"],
          intervalLengthMinutes: 15
        };
        
        if (planningGroupIds.length > 0) {
          requestBody.planningGroupIds = planningGroupIds;
        }
        
        const response = await fetch(`https://api.${CONFIG.region}/api/v2/workforcemanagement/businessunits/${businessUnitId}/intraday`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + state.accessToken
          },
          body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
          if (response.status === 404) {
            return { date, data: null, error: 'No forecast data available for this date' };
          }
          if (response.status === 429) {
            throw new Error('Rate limit exceeded - please try a smaller date range');
          }
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        let data = await response.json();
        if (data.status && data.status !== 'Complete' && data.operationId) {
          data = await pollIntradayResult(businessUnitId, data.operationId);
        }
        
        return { date, data };
      } catch (error) {
        return { date, data: null, error: error.message };
      }
    }

    function processDayData(data) {
      if (!data?.result?.intradayDataGroupings) return [];
      
      const mediaTypeFilter = document.getElementById('mediaType').value;
      const selectedPlanningGroups = state.planningGroupDropdown.getSelectedValues();
      
      return data.result.intradayDataGroupings
        .filter(g => (!mediaTypeFilter || g.mediaType === mediaTypeFilter) &&
                    (!g.planningGroupId || selectedPlanningGroups.length === 0 || selectedPlanningGroups.includes(g.planningGroupId)))
        .map(g => ({
          forecast: g.forecastDataSummary || {},
          prediction: getPerformancePredictionData(g),
          planningGroupId: g.planningGroupId
        }));
    }

    async function fetchDataForDateRange(startDate, endDate) {
      const days = getDateRange(startDate, endDate);
      const totalDays = days.length;
      const selectedPlanningGroups = state.planningGroupDropdown.getSelectedValues();
      
      if (state.isFetchingData) {
        showMessage('A data fetch is already in progress', 'error');
        return;
      }
      
      state.isFetchingData = true;
      state.fetchCancelled = false;
      state.dateRangeData = [];
      
      showProgressBar();
      updateProgress(0, totalDays, 'Starting data fetch...');
      
      try {
        if (totalDays > 30) {
          showMessage(`Fetching ${totalDays} days of forecast data. Wider date ranges may take longer to generate`, 'info');
        }
        
        const batchSize = CONFIG.maxDaysPerRequest;
        let processed = 0;
        
        for (let i = 0; i < totalDays; i += batchSize) {
          if (state.fetchCancelled) {
            showMessage('Data fetch cancelled', 'info');
            break;
          }
          
          const batch = days.slice(i, Math.min(i + batchSize, totalDays));
          const batchResults = [];
          
          updateProgress(processed, totalDays, `Fetching batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(totalDays/batchSize)}...`);
          
          for (let j = 0; j < batch.length; j++) {
            if (state.fetchCancelled) break;
            
            const day = batch[j];
            updateProgress(processed + j, totalDays, `Fetching ${day.uk}...`);
            
            const result = await fetchIntradayData(day.raw, selectedPlanningGroups);
            batchResults.push({
              ...result, 
              uk: day.uk,
              date: day.date,
              groupData: processDayData(result.data)
            });
            
            if (j < batch.length - 1) {
              await new Promise(resolve => setTimeout(resolve, CONFIG.delayBetweenRequests));
            }
            
            processed++;
            updateProgress(processed, totalDays);
          }
          
          state.dateRangeData.push(...batchResults);
          
          if (i + batchSize < totalDays && !state.fetchCancelled) {
            updateProgress(processed, totalDays, 'Pausing between batches...');
            await new Promise(resolve => setTimeout(resolve, CONFIG.delayBetweenBatches));
          }
        }
        
        if (!state.fetchCancelled) {
          state.isDataLoaded = true;
          refreshMediaTypeOptions();
          renderAllData();
          showMessage(`Successfully loaded ${processed} days of forecast data!`, 'success');
        }
        
      } catch (error) {
        showMessage('Error fetching data: ' + error.message, 'error');
      } finally {
        state.isFetchingData = false;
        hideProgressBar();
        document.getElementById('loadDataBtn').disabled = false;
        document.getElementById('loadDataBtn').textContent = 'Load Forecast Data';
      }
    }

    // ===== UI Event Handlers =====
    function onBusinessUnitChange() {
      const businessUnitId = this.value;
      
      if (businessUnitId) {
        fetchPlanningGroups(businessUnitId);
      }
      updateLoadButtonState();
    }

    function updateLoadButtonState() {
      const businessUnitId = document.getElementById('businessUnitSelect').value;
      const selectedPlanningGroups = state.planningGroupDropdown ? state.planningGroupDropdown.getSelectedValues() : [];
      const dateFrom = document.getElementById('dateFrom').value;
      const dateTo = document.getElementById('dateTo').value;
      
      document.getElementById('loadDataBtn').disabled = !(businessUnitId && dateFrom && dateTo);
    }

    function loadData() {
      const dateFrom = document.getElementById('dateFrom').value;
      const dateTo = document.getElementById('dateTo').value;
      
      if (!dateFrom || !dateTo) {
        showMessage('Please select both start and end dates', 'error');
        return;
      }
      
      if (new Date(dateFrom) > new Date(dateTo)) {
        showMessage('End date must be after start date', 'error');
        return;
      }
      
      const dayCount = Math.ceil((new Date(dateTo) - new Date(dateFrom)) / (1000 * 60 * 60 * 24)) + 1;
      
      if (dayCount > 365) {
        showMessage('Please select a date range of 365 days or less for performance reasons', 'info');
        return;
      }
      
      state.dateFrom = dateFrom;
      state.dateTo = dateTo;
      
      document.getElementById('loadDataBtn').disabled = true;
      document.getElementById('loadDataBtn').textContent = 'Loading...';
      document.getElementById('consolidatedSection').style.display = 'none';
      
      fetchDataForDateRange(dateFrom, dateTo);
    }

    function setActiveTab(tabName) {
      document.getElementById('dailyTabButton').classList.toggle('active', tabName === 'daily');
      document.getElementById('intervalTabButton').classList.toggle('active', tabName === 'interval');
      document.getElementById('chartsTabButton').classList.toggle('active', tabName === 'charts');
      
      document.getElementById('dailyTab').classList.toggle('active', tabName === 'daily');
      document.getElementById('intervalTab').classList.toggle('active', tabName === 'interval');
      document.getElementById('chartsTab').classList.toggle('active', tabName === 'charts');

      if (tabName === 'charts') {
        updateCharts();
      }
    }

    // ===== Data Rendering Functions =====
    function renderAllData() {
      renderConsolidatedTable();
      updateCharts();
    }

    function renderConsolidatedTable() {
      const container = document.getElementById('consolidatedTableContainer');
      const planningGroups = groupsPresent();
      
      if (planningGroups.length === 0) {
        container.innerHTML = '<div class="no-data">No planning groups in data.</div>';
        document.getElementById('consolidatedSection').style.display = 'none';
        return;
      }

      const viewType = document.getElementById('viewType').value;
      
      let html = '';
      
      planningGroups.forEach(group => {
        html += `
          <div class="table-container" style="margin-bottom:30px;">
            <table class="consolidated-table">
              <tr>
                <th colspan="7" class="group-header">Planning Group: ${group.name} - ${viewType.toUpperCase()} VIEW</th>
              </tr>
              <tr>
                <th class="sub-header">Period</th>
                <th class="sub-header">Offered</th>
                <th class="sub-header">Avg Handle Time</th>
                <th class="sub-header">Service Level</th>
                <th class="sub-header">Avg Speed Answer</th>
                <th class="sub-header">Occupancy</th>
                <th class="sub-header">Staffed</th>
              </tr>
        `;

        const groupData = state.dateRangeData.map(day => ({
          ...day,
          groupData: day.groupData?.filter(g => !g.planningGroupId || g.planningGroupId === group.id) || []
        }));

        const aggregatedData = aggregateDataByPeriod(groupData, viewType);
        
        let grandTotals = { offered: 0, aht: 0, ahtCount: 0, sl: 0, slCount: 0, asa: 0, asaCount: 0, occupancy: 0, occupancyCount: 0, staffed: 0 };

        aggregatedData.forEach(period => {
          grandTotals.offered += period.offered;
          grandTotals.aht += period.aht;
          grandTotals.ahtCount += period.ahtCount;
          grandTotals.sl += period.sl;
          grandTotals.slCount += period.slCount;
          grandTotals.asa += period.asa;
          grandTotals.asaCount += period.asaCount;
          grandTotals.occupancy += period.occupancy;
          grandTotals.occupancyCount += period.occupancyCount;
          grandTotals.staffed += period.staffed;

          html += `
            <tr class="clickable-row" data-period="${period.label}" data-raw-date="${period.rawDate || ''}">
              <td>${period.label}</td>
              <td>${formatNumber(period.offered)}</td>
              <td>${formatTime(period.ahtCount > 0 ? period.aht / period.ahtCount : 0)}</td>
              <td>${formatPercentage(period.slCount > 0 ? period.sl / period.slCount : null)}</td>
              <td>${formatTime(period.asaCount > 0 ? period.asa / period.asaCount : null)}</td>
              <td>${formatPercentage(period.occupancyCount > 0 ? period.occupancy / period.occupancyCount : null)}</td>
              <td>${formatNumber(period.staffed)}</td>
            </tr>
          `;
        });

        html += `
          <tr class="weekly-totals-row">
            <td><strong>GRAND TOTAL</strong></td>
            <td><strong>${formatNumber(grandTotals.offered)}</strong></td>
            <td><strong>${formatTime(grandTotals.ahtCount > 0 ? grandTotals.aht / grandTotals.ahtCount : 0)}</strong></td>
            <td><strong>${formatPercentage(grandTotals.slCount > 0 ? grandTotals.sl / grandTotals.slCount : null)}</strong></td>
            <td><strong>${formatTime(grandTotals.asaCount > 0 ? grandTotals.asa / grandTotals.asaCount : null)}</strong></td>
            <td><strong>${formatPercentage(grandTotals.occupancyCount > 0 ? grandTotals.occupancy / grandTotals.occupancyCount : null)}</strong></td>
            <td><strong>${formatNumber(grandTotals.staffed)}</strong></td>
          </tr>
        `;

        html += `</table></div>`;
      });

      container.innerHTML = html;
      document.getElementById('consolidatedSection').style.display = 'block';
      document.getElementById('weeklySummary').style.display = 'none';

      document.querySelectorAll('.clickable-row').forEach(row => {
        row.addEventListener('click', function() {
          const period = this.getAttribute('data-period');
          const rawDate = this.getAttribute('data-raw-date');
          showIntervalData(period, rawDate);
        });
      });
    }

    function showIntervalData(period, rawDate) {
      console.log('showIntervalData called with:', { period, rawDate });
      state.selectedDayForIntervals = period;
      
      // Find the day data
      let dayData;
      if (rawDate) {
        dayData = state.dateRangeData.find(d => d.uk === rawDate);
      } else {
        const dateMatch = period.match(/(\d{2}\/\d{2}\/\d{4})/);
        if (dateMatch) {
          dayData = state.dateRangeData.find(d => d.uk === dateMatch[1]);
        }
      }

      if (!dayData) {
        showMessage('No data found for selected day', 'error');
        return;
      }

      state.selectedDayData = dayData;
      document.getElementById('selectedDayTitle').textContent = period;
      
      setActiveTab('interval');
      renderIntervalTable();
    }

    function generateIntervalsForDay(intervalLength = 15) {
      const intervals = [];
      const startHour = parseInt(state.intervalFilter.openTime.split(':')[0]);
      const startMinute = parseInt(state.intervalFilter.openTime.split(':')[1]);
      const endHour = parseInt(state.intervalFilter.closeTime.split(':')[0]);
      const endMinute = parseInt(state.intervalFilter.closeTime.split(':')[1]);
      
      const startTotalMinutes = startHour * 60 + startMinute;
      const endTotalMinutes = endHour * 60 + endMinute;
      
      for (let minutes = startTotalMinutes; minutes < endTotalMinutes; minutes += intervalLength) {
        const hour = Math.floor(minutes / 60);
        const minute = minutes % 60;
        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        intervals.push({
          time: timeString,
          offered: 0,
          aht: 0,
          sl: '-',
          asa: 0,
          occupancy: '-',
          staffed: 0
        });
      }
      return intervals;
    }

    function renderIntervalTable() {
      if (!state.selectedDayData || !state.selectedDayData.data?.result?.intradayDataGroupings) {
        document.getElementById('intervalTableContainer').innerHTML = '<div class="no-data">No interval data available for this date</div>';
        return;
      }

      const container = document.getElementById('intervalTableContainer');
      const mediaTypeFilter = document.getElementById('mediaType').value;
      const selectedPlanningGroups = state.planningGroupDropdown.getSelectedValues();
      const intervalLength = parseInt(document.getElementById('intervalLength').value);
      
      // Get planning groups from the day's data
      const planningGroups = [];
      state.selectedDayData.data.result.intradayDataGroupings.forEach(group => {
        if (group.planningGroupId) {
          const name = state.planningGroupsMap[group.planningGroupId] || `Group ${group.planningGroupId}`;
          if (!planningGroups.some(pg => pg.id === group.planningGroupId)) {
            planningGroups.push({ id: group.planningGroupId, name });
          }
        }
      });

      // Filter by selected planning groups if any are selected
      const filteredPlanningGroups = selectedPlanningGroups.length > 0 
        ? planningGroups.filter(pg => selectedPlanningGroups.includes(pg.id))
        : planningGroups;

      if (filteredPlanningGroups.length === 0) {
        container.innerHTML = '<div class="no-data">No planning groups found for the selected filters</div>';
        return;
      }

      let html = '';
      state.currentIntervalData = [];

      filteredPlanningGroups.forEach(group => {
        // Find group data
        const groupData = state.selectedDayData.data.result.intradayDataGroupings.find(g => 
          g.planningGroupId === group.id && 
          (!mediaTypeFilter || g.mediaType === mediaTypeFilter)
        );

        if (!groupData || !groupData.forecastDataPerInterval) {
          html += `
            <div class="table-container" style="margin-bottom:30px;">
              <table class="consolidated-table">
                <tr>
                  <th colspan="7" class="group-header">Planning Group: ${group.name} - No interval data available</th>
                </tr>
              </table>
            </div>
          `;
          return;
        }

        // Generate intervals based on selected time range and interval length
        const intervals = generateIntervalsForDay(intervalLength);
        
        // Map 15-minute API data to our intervals
        groupData.forecastDataPerInterval.forEach((apiInterval, index) => {
          const apiHour = Math.floor(index / 4);
          const apiMinute = (index % 4) * 15;
          const apiTimeString = `${apiHour.toString().padStart(2, '0')}:${apiMinute.toString().padStart(2, '0')}`;
          
          // Find matching interval
          const targetInterval = intervals.find(int => int.time === apiTimeString);
          if (targetInterval) {
            const forecast = apiInterval.forecast || {};
            const prediction = apiInterval.performancePrediction || {};
            
            targetInterval.offered = forecast.offered || 0;
            targetInterval.aht = forecast.averageHandleTimeSeconds || 0;
            targetInterval.sl = prediction?.serviceLevelPercent ? prediction.serviceLevelPercent : '-';
            targetInterval.asa = prediction?.averageSpeedOfAnswerSeconds || 0;
            targetInterval.occupancy = prediction?.occupancyPercent ? prediction.occupancyPercent : '-';
            targetInterval.staffed = forecast.staffed || 0;
          }
        });

        // Store for CSV export
        state.currentIntervalData.push({
          groupName: group.name,
          intervals: intervals.map(interval => ({
            time: interval.time,
            offered: interval.offered,
            aht: interval.aht,
            sl: interval.sl === '-' ? '-' : formatPercentage(interval.sl),
            asa: interval.asa,
            occupancy: interval.occupancy === '-' ? '-' : formatPercentage(interval.occupancy),
            staffed: interval.staffed
          }))
        });

        html += `
          <div class="table-container" style="margin-bottom:30px;">
            <table class="consolidated-table">
              <tr>
                <th colspan="7" class="group-header">Planning Group: ${group.name} - ${intervalLength}-min Intervals (${state.intervalFilter.openTime} - ${state.intervalFilter.closeTime})</th>
              </tr>
              <tr>
                <th class="sub-header">Time</th>
                <th class="sub-header">Offered</th>
                <th class="sub-header">Avg Handle Time</th>
                <th class="sub-header">Service Level</th>
                <th class="sub-header">Avg Speed Answer</th>
                <th class="sub-header">Occupancy</th>
                <th class="sub-header">Staffed</th>
              </tr>
        `;

        intervals.forEach(interval => {
          const slDisplay = interval.sl === '-' ? '-' : formatPercentage(interval.sl);
          const occupancyDisplay = interval.occupancy === '-' ? '-' : formatPercentage(interval.occupancy);
          
          html += `
            <tr>
              <td>${interval.time}</td>
              <td>${formatNumber(interval.offered)}</td>
              <td>${formatTime(interval.aht)}</td>
              <td>${slDisplay}</td>
              <td>${formatTime(interval.asa)}</td>
              <td>${occupancyDisplay}</td>
              <td>${formatNumber(interval.staffed)}</td>
            </tr>
          `;
        });

        html += `</table></div>`;
      });

      container.innerHTML = html;
    }

    function getAllMediaTypesFromData() {
      const mediaTypes = new Set();
      state.dateRangeData.forEach(day => {
        day.data?.result?.intradayDataGroupings?.forEach(group => {
          if (group.mediaType) mediaTypes.add(group.mediaType);
        });
      });
      return Array.from(mediaTypes);
    }

    function refreshMediaTypeOptions() {
      const mediaTypes = getAllMediaTypesFromData();
      const select = document.getElementById('mediaType');
      const currentValue = select.value;
      
      select.innerHTML = `<option value="">-- All Media Types --</option>` + 
        mediaTypes.map(type => `<option value="${type}">${type}</option>`).join('');
      
      if (mediaTypes.includes(currentValue) || currentValue === '') {
        select.value = currentValue;
      }
    }

    function groupsPresent() {
      const groupsMap = new Map();
      
      state.dateRangeData.forEach(day => {
        day.data?.result?.intradayDataGroupings?.forEach(group => {
          const id = group.planningGroupId;
          if (id) {
            const name = state.planningGroupsMap[id] || `Group ${id}`;
            groupsMap.set(id, { id, name });
          }
        });
      });
      
      return Array.from(groupsMap.values());
    }

    // ===== Chart Functions =====
    function updateCharts() {
      if (!state.isDataLoaded) {
        document.getElementById('chartsDataContainer').innerHTML = '<div class="no-data">Load forecast data to view charts</div>';
        return;
      }

      renderChart(state.currentChartType);
    }

    function renderChart(chartType) {
      const ctx = document.getElementById('metricsChart').getContext('2d');
      
      if (state.charts.metrics) {
        state.charts.metrics.destroy();
      }

      const planningGroups = groupsPresent();
      
      if (planningGroups.length === 0) {
        return;
      }

      const group = planningGroups[0];
      const labels = [];
      const offeredData = [];
      const ahtData = [];
      const serviceLevelData = [];
      const occupancyData = [];

      const groupData = state.dateRangeData.map(day => ({
        ...day,
        groupData: day.groupData?.filter(g => !g.planningGroupId || g.planningGroupId === group.id) || []
      }));

      const chartViewType = document.getElementById('chartViewType').value;
      const aggregatedData = aggregateDataByPeriod(groupData, chartViewType);
      
      aggregatedData.forEach(period => {
        labels.push(period.label);
        offeredData.push(period.offered);
        ahtData.push(period.ahtCount > 0 ? period.aht / period.ahtCount : 0);
        
        const avgServiceLevel = period.slCount > 0 ? (period.sl / period.slCount) * 100 : null;
        serviceLevelData.push(avgServiceLevel);
        
        const avgOccupancy = period.occupancyCount > 0 ? (period.occupancy / period.occupancyCount) * 100 : null;
        occupancyData.push(avgOccupancy);
      });

      let chartConfig;

      switch(chartType) {
        case 'serviceLevel':
          chartConfig = {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Service Level %',
                  data: serviceLevelData,
                  borderColor: 'rgba(75, 192, 192, 1)',
                  backgroundColor: 'rgba(75, 192, 192, 0.2)',
                  borderWidth: 3,
                  fill: true,
                  tension: 0.4
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: {
                  display: true,
                  text: `Service Level Predictions - ${chartViewType} View`
                }
              },
              scales: {
                y: {
                  min: 0,
                  max: 100,
                  title: {
                    display: true,
                    text: 'Service Level %'
                  }
                }
              }
            }
          };
          break;

        case 'occupancy':
          chartConfig = {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Occupancy %',
                  data: occupancyData,
                  borderColor: 'rgba(153, 102, 255, 1)',
                  backgroundColor: 'rgba(153, 102, 255, 0.2)',
                  borderWidth: 3,
                  fill: true,
                  tension: 0.4
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: {
                  display: true,
                  text: `Occupancy Predictions - ${chartViewType} View`
                }
              },
              scales: {
                y: {
                  min: 0,
                  max: 100,
                  title: {
                    display: true,
                    text: 'Occupancy %'
                  }
                }
              }
            }
          };
          break;

        case 'volume':
        default:
          chartConfig = {
            type: 'bar',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Offered Volume',
                  data: offeredData,
                  backgroundColor: 'rgba(99, 171, 143, 0.8)',
                  borderColor: 'rgba(99, 171, 143, 1)',
                  borderWidth: 1,
                  yAxisID: 'y'
                },
                {
                  label: 'Average Handle Time',
                  data: ahtData,
                  type: 'line',
                  borderColor: 'rgba(255, 99, 132, 1)',
                  backgroundColor: 'rgba(255, 99, 132, 0.2)',
                  borderWidth: 2,
                  fill: false,
                  yAxisID: 'y1'
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              stacked: false,
              plugins: {
                title: {
                  display: true,
                  text: `Offered Volume vs Average Handle Time - ${chartViewType} View`
                }
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  title: {
                    display: true,
                    text: 'Offered Volume'
                  },
                  beginAtZero: true
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  title: {
                    display: true,
                    text: 'Average Handle Time (seconds)'
                  },
                  beginAtZero: true,
                  grid: {
                    drawOnChartArea: false,
                  },
                }
              }
            }
          };
      }

      state.charts.metrics = new Chart(ctx, chartConfig);
      document.getElementById('chartsDataContainer').innerHTML = '';
    }

    // ===== Authentication =====
    document.addEventListener('DOMContentLoaded', () => {
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const queryParams = new URLSearchParams(window.location.search);

      const oauthError = params.get('error') || queryParams.get('error');
      const oauthErrorDesc = params.get('error_description') || queryParams.get('error_description');

      if (oauthError) {
        document.getElementById('auth-message').textContent = `OAuth error: ${oauthErrorDesc || oauthError}`;
        document.getElementById('auth-message').className = 'error-message';
        if (DEBUG) showDebugCard();
        return;
      }

      const tokenFromHash = params.get('access_token');
      const tokenFromSession = sessionStorage.getItem('purecloud_token');

      if (tokenFromHash) {
        state.accessToken = tokenFromHash;
        sessionStorage.setItem('purecloud_token', state.accessToken);
        history.replaceState(null, '', window.location.href.split('#')[0]);
        initializeApplication();
      } else if (tokenFromSession) {
        state.accessToken = tokenFromSession;
        initializeApplication();
      } else {
        if (DEBUG) showDebugCard();
        else window.location.href = oauthUrl;
      }
    });

    function showDebugCard() {
      const debugInfo = {
        clientId: CONFIG.clientId,
        redirectUri: redirectUri,
        oauthUrl: oauthUrl,
        region: CONFIG.region
      };
      
      document.getElementById('authDebug').style.display = 'block';
      document.getElementById('authDump').textContent = JSON.stringify(debugInfo, null, 2);
      document.getElementById('signinBtn').onclick = () => location.href = oauthUrl;
      document.getElementById('auth-message').textContent = 'Debug mode: click "Sign in with Genesys".';
      document.getElementById('auth-message').className = 'info-message';
    }

    function initializeApplication() {
      document.getElementById('auth-message').textContent = 'Authenticated successfully!';
      document.getElementById('auth-message').className = 'success-message';
      
      setTimeout(() => {
        document.getElementById('authCard').style.display = 'none';
        document.getElementById('authDebug').style.display = 'none';
      }, 1200);

      document.getElementById('appContent').style.display = 'block';
      initializeApp();
    }

    function initializeApp() {
      // Create planning group dropdown
      state.planningGroupDropdown = createCheckboxDropdown('planningGroupDropdown', {
        placeholder: 'Select Planning Groups',
        searchPlaceholder: 'Search planning groups...'
      });

      document.getElementById('businessUnitSelect').addEventListener('change', onBusinessUnitChange);
      document.getElementById('mediaType').addEventListener('change', onConfigChange);
      document.getElementById('viewType').addEventListener('change', onConfigChange);
      document.getElementById('chartViewType').addEventListener('change', updateCharts);
      document.getElementById('loadDataBtn').addEventListener('click', loadData);
      
      // Export buttons
      document.getElementById('exportForecastBtn').addEventListener('click', exportForecastData);
      document.getElementById('exportIntervalBtn').addEventListener('click', exportIntervalData);
      
      // Tab navigation
      document.getElementById('dailyTabButton').addEventListener('click', () => setActiveTab('daily'));
      document.getElementById('intervalTabButton').addEventListener('click', () => setActiveTab('interval'));
      document.getElementById('chartsTabButton').addEventListener('click', () => setActiveTab('charts'));
      
      // Chart tabs
      document.querySelectorAll('.chart-tab').forEach(tab => {
        tab.addEventListener('click', function() {
          document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
          this.classList.add('active');
          state.currentChartType = this.getAttribute('data-chart');
          updateCharts();
        });
      });
      
      // Time format toggles
      document.getElementById('timeFormatToggle').addEventListener('change', function() {
        state.timeFormat = this.checked ? 'seconds' : 'hhmmss';
        updateTimeFormatLabels();
        if (state.isDataLoaded) {
          renderAllData();
        }
      });
      
      document.getElementById('intervalTimeFormatToggle').addEventListener('change', function() {
        state.timeFormat = this.checked ? 'seconds' : 'hhmmss';
        updateTimeFormatLabels();
        if (state.selectedDayForIntervals && state.isDataLoaded) {
          renderIntervalTable();
        }
      });
      
      // Sync the toggles
      document.getElementById('timeFormatToggle').addEventListener('change', function() {
        document.getElementById('intervalTimeFormatToggle').checked = this.checked;
      });
      
      document.getElementById('intervalTimeFormatToggle').addEventListener('change', function() {
        document.getElementById('timeFormatToggle').checked = this.checked;
      });
      
      // Interval controls
      document.getElementById('intervalLength').addEventListener('change', function() {
        state.intervalFilter.intervalLength = parseInt(this.value);
        if (state.selectedDayData) {
          renderIntervalTable();
        }
      });
      
      document.getElementById('openTime').addEventListener('change', function() {
        state.intervalFilter.openTime = this.value;
      });
      
      document.getElementById('closeTime').addEventListener('change', function() {
        state.intervalFilter.closeTime = this.value;
      });
      
      document.getElementById('applyIntervalFilter').addEventListener('click', function() {
        state.intervalFilter.openTime = document.getElementById('openTime').value;
        state.intervalFilter.closeTime = document.getElementById('closeTime').value;
        if (state.selectedDayData) {
          renderIntervalTable();
        }
      });
      
      updateTimeFormatLabels();
      
      // Set default dates
      const today = new Date();
      const lastWeek = new Date();
      lastWeek.setDate(today.getDate() - 7);
      
      document.getElementById('dateFrom').value = lastWeek.toISOString().split('T')[0];
      document.getElementById('dateTo').value = today.toISOString().split('T')[0];
      
      fetchBusinessUnits();
    }

    function onConfigChange() {
      if (state.isDataLoaded) {
        renderAllData();
        updateCharts();
      }
    }
  </script>
</body>
</html>
